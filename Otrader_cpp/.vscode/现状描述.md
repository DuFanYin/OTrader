# Otrader 现状描述

---

## 一、架构目标简述（对照用）

- **Domain Core**：纯逻辑。接收 Event，更新状态，输出 Intent；不直接下单、不读库、不访问网关。
- **Runtime**：live/backtest 差异集中在此。接入行情与时钟，执行 Core 产出的 Intent（下单/撤单/撮合），将执行结果转为 Event 回灌。
- **统一形态**：Event 入、Intent 出。输入 Event 流（Timer、Snapshot、行情、成交、订单回报等）；输出 Intent（OrderIntent、CancelIntent、LogIntent）。Core 只产出 Intent，执行由 Runtime 完成。
- **驱动方式**：事件发到引擎后，在**同一处**按**写死顺序**调用；Log 单一 sink，由 LogEngine level 统一控制。

下文描述当前代码与上述目标的对应关系及实现细节。

---

## 二、目录与模块

```
Otrader/
├── CMakeLists.txt
├── entry_backtest.cpp
├── backtest/
│   ├── CMakeLists.txt
│   ├── engines/
│   │   ├── engine_backtest.{cpp,hpp}, engine_main.{cpp,hpp}, engine_strategy.{cpp,hpp}
│   │   ├── engine_event.{cpp,hpp}, engine_data.{cpp,hpp}
│   │   └── CMakeLists.txt
│   └── utils/
│       ├── parquet_loader.{cpp,hpp}, occ_utils.{cpp,hpp}, types.hpp, lets_be_rational_api.hpp
├── core/
│   ├── engine_position.{cpp,hpp}, engine_hedge.{cpp,hpp}, engine_combo_builder.{cpp,hpp}
│   ├── engine_log.{cpp,hpp}, log_sink.hpp
│   └── CMakeLists.txt
├── live/
│   ├── engine_main.{cpp,hpp}, engine_event.{cpp,hpp}, engine_strategy.{cpp,hpp}
│   ├── engine_data.{cpp,hpp}, engine_db.{cpp,hpp}, engine_gateway.{cpp,hpp}
│   └── CMakeLists.txt
├── strategy/
│   ├── template.{cpp,hpp}, high_frequency_momentum.{cpp,hpp}
├── tests/
│   ├── test_backtest.{cpp}, test_backtest_data.cpp, test_entry_multi.cpp
│   └── CMakeLists.txt
├── utilities/
│   ├── event.hpp, portfolio.{cpp,hpp}, object.{cpp,hpp}, constant.hpp, utility.{cpp,hpp}, base_engine.hpp
│   └── CMakeLists.txt
└── thirdparty/
    └── lets_be_rational/...
```

- **回测**：BacktestEngine 持有 EventEngine 与 MainEngine；MainEngine 构造时传入 event_engine，并通过 set_order_executor 注入 BacktestEngine::execute_order 作为撮合执行器。MainEngine 持有 OptionStrategyEngine、BacktestDataEngine、PositionEngine、HedgeEngine、ComboBuilderEngine、LogEngine。事件由 BacktestEngine::run() 在每时间步先 put_event(Snapshot) 再 put_event(Timer) 驱动；订单/成交回报经 main_engine_->put_event(Order/Trade) 回灌（MainEngine::put_event 转发到 event_engine_->put_event）。
- **实盘**：engines::MainEngine 持有 EventEngine、LogEngine、DatabaseEngine、MarketDataEngine、IbGateway、OptionStrategyEngine、PositionEngine、HedgeEngine、ComboBuilderEngine。EventEngine 内部队列 + 定时器线程 put(Timer)；外部回报经 main_engine->put_event 入队。下单/撤单经 MainEngine 转 IbGateway。
- **Core**：`core/` 下各引擎均为「caller passes ... from outside (no context interface)」，无 Context，全部由调用方传参。
- **BaseEngine**：仅持 `MainEngine* main_engine` 与 `engine_name`，**不持 IEventEngine**。策略与 Hedge 侧统一通过 MainEngine 的 append_order/append_cancel/append_log 提交意图，不直接持有或调用 event_engine。

---

## 三、Event 与 Intent

### 3.1 Event 形态

- **定义**（`utilities/event.hpp`）：`EventType` 为 `Timer`、`Order`、`Trade`、`Contract`、`Snapshot`；`EventPayload` 为 `variant<monostate, OrderData, TradeData, ContractData, PortfolioSnapshot>`。无独立 Log 事件类型，Log 以 Intent（LogData）经 put_log_intent/append_log 提交。
- **事件入口**：
  - 回测：BacktestEngine 每步先 `event_engine_->put_event(Event(Snapshot, data_engine->get_precomputed_snapshot(step_count)))`，再 `event_engine_->put_event(Timer)`；撮合回报调 `main_engine_->put_event(Order/Trade)`，MainEngine::put_event 转发到 `event_engine_->put_event(e)`，EventEngine::put_event 内同步 process(event)。
  - Live：定时器或外部回调调 `event_engine->put(event)` 入队，worker 线程 process(event)；回报也可经 main_engine->put_event(e) 转发到 event_engine->put(e) 入队。
- **utilities::MainEngine**：虚函数 `put_event(const Event& e)` 默认 no-op。backtest::MainEngine 与 engines::MainEngine 均 override，内部转 `event_engine_->put_event(e)`（回测同步、live 入队）。

### 3.2 Intent 提交：append_* 与 put_intent_*

- **Strategy/Hedge 只调 append_***：回测与 live 的 OptionStrategyEngine 均**不持 event_engine**，只持 main_engine。下单、撤单、日志统一经 `main_engine_->append_order(req)`、`append_cancel(req)`、`append_log(log)` 提交。MainEngine 的 append_* 内部直接转 send_order/cancel_order/put_log_intent，不经过 IEventEngine。
- **append_* 语义**：回测与 live 的 MainEngine 均提供 append_order、append_cancel、append_log。回测：append_order → send_order（order_executor 撮合），append_cancel → cancel_order（更新状态并 put_event(Order)），append_log → put_log_intent。Live：append_order → send_order（IbGateway），append_cancel → cancel_order，append_log → put_log_intent。
- **IEventEngine::put_intent_***：由 backtest/live 的 EventEngine 实现，实现内转 main_engine_->send_order/cancel_order/put_log_intent。当前策略与 Hedge 产出已不走 put_intent_*，而走 append_*；put_intent_* 保留给需要「经事件引擎路由」的调用方（若有）。EventEngine 在 dispatch_timer 中执行 Hedge 产出的 orders/cancels/logs 时，直接调 main_engine_->send_order/cancel_order/put_log_intent，不经过 put_intent_*。

### 3.3 Log 路径

- **写日志**：策略 write_log → OptionStrategyEngine::put_log_intent/write_log → main_engine->append_log(intent)；append_log 内部 put_log_intent → LogEngine::process_log_intent。策略禁止直接 cout，需经 engine_->write_log/put_log_intent → append_log。
- **Log 控制**（回测与 live 一致）：由 LogEngine 的 level 控制。仅当 `data.level >= level_` 时输出；`engines::DISABLED`(99) 关闭全部。MainEngine 暴露 `set_log_level(level)` / `log_level()`，转发到 LogEngine（set_level/level）。put_log_intent 直接调 log_engine_->process_log_intent，门控在 LogEngine 内。
- **LogEngine**：构造为 `LogEngine(utilities::MainEngine* main_engine)`，仅一参；**不持 IEventEngine**。process_log_intent 内先按 level 过滤，再 set_sink 或 default_sink 输出。

---

## 四、Core 层（无 Context，caller 传参）

### 4.1 PositionEngine

- **接口**：`process_timer_event(GetPortfolioFn get_portfolio, std::vector<LogData>* out_logs = nullptr)`、`update_metrics(strategy_name, portfolio)`、`process_order(order)`、`process_trade(strategy_name, trade)`。无 WriteLogFn；若需写 log 则向 out_logs 追加 LogData，由调用方统一 put_log_intent/append_log。
- **调用方**：回测 EventEngine::dispatch_timer 只调 `update_metrics`（不调 process_timer_event）。Live EventEngine::dispatch_timer 先调 position_engine()->process_timer_event(get_portfolio, &pos_logs)，再对 pos_logs 逐条 main_engine_->put_log_intent(l)。

### 4.2 HedgeEngine

- **接口**：`process_hedging(strategy_name, HedgeParams params, out_orders, out_cancels, out_logs)`，向调用方提供的三个 vector 追加 OrderRequest、CancelRequest、LogData。HedgeParams 仅只读：portfolio、holding、get_contract、get_strategy_active_orders、get_order；无执行类回调。执行由 Runtime 对产出的 orders/cancels/logs 分别调 send_order/cancel_order/put_log_intent。
- **调用方**：回测与 live 的 EventEngine::dispatch_timer 内组 HedgeParams，调 process_hedging 得到填充后的 orders/cancels/logs，再逐条 main_engine_->send_order/cancel_order/put_log_intent。

### 4.3 ComboBuilderEngine

- **接口**：`combo_builder(..., get_contract_fn, std::vector<LogData>* out_logs = nullptr)` 等，纯函数；日志向 out_logs 追加，由调用方打出。
- **调用方**：strategy/template、live OptionStrategyEngine::build_combo 传 get_contract 与 out_logs，调用后对 out_logs 逐条 write_log/append_log。

---

## 五、事件流与写死顺序

### 5.1 回测

- **驱动**：BacktestEngine::run() 内 data_engine->iter_timesteps：每步先 `event_engine_->put_event(Event(Snapshot, data_engine->get_precomputed_snapshot(step_count)))`，再 `event_engine_->put_event(Event(Timer))`。
- **EventEngine::put_event**：直接 process(event)，按 event.type 调 dispatch_snapshot / dispatch_timer / dispatch_order / dispatch_trade。
- **dispatch_snapshot**：从 event.data 取 PortfolioSnapshot，main_engine_->get_portfolio(snap->portfolio_name)，若存在则 portfolio->apply_frame(*snap)。用于每步先更新 portfolio 价格/Greeks，再触发 Timer。
- **dispatch_timer 固定顺序**：  
  1）se->get_strategy()->on_timer()；  
  2）position_engine()->update_metrics(strategy_name, portfolio)；  
  3）hedge_engine()->process_hedging(..., out_orders, out_cancels, out_logs)；  
  4）对 out_orders/out_cancels/out_logs 逐条 main_engine_->send_order/cancel_order/put_log_intent。  
  无 handler 注册。
- **dispatch_order**：position_engine()->process_order(order)；option_strategy_engine()->process_order(order)。
- **dispatch_trade**：position_engine()->process_trade(strategy_name, trade)；option_strategy_engine()->process_trade(trade)。
- **回报回灌**：BacktestEngine::execute_order 内 main_engine_->add_order、main_engine_->put_event(Order)、main_engine_->put_event(Trade)（及 combo 各 leg 的 Trade）。MainEngine::put_event 转 event_engine_->put_event，EventEngine 同步 process，从而触发 dispatch_order/dispatch_trade。

### 5.2 Live

- **驱动**：EventEngine run_timer 线程按 interval 秒 put(Timer)；外部 put(Order/Trade/Contract/Snapshot)。run() 线程从队列取 event 调 process(event)。
- **process(event)**：按 type 调 dispatch_snapshot / dispatch_timer / dispatch_order / dispatch_trade / dispatch_contract。
- **dispatch_snapshot**：与回测相同，get_portfolio(snap->portfolio_name)->apply_frame(*snap)。Live 下 Snapshot 可由行情侧组装后 put 入队。
- **dispatch_timer 固定顺序**：  
  1）position_engine()->process_timer_event(get_portfolio, &pos_logs)，再对 pos_logs 逐条 put_log_intent；  
  2）对 hedge 的每个 registered_strategy：组 HedgeParams，process_hedging(..., &orders, &cancels, &logs)，再对 orders/cancels/logs 逐条 send_order/cancel_order/put_log_intent。  
  Live 的 dispatch_timer 内无策略 on_timer 调用。
- **dispatch_order / dispatch_trade / dispatch_contract**：与回测类似，position_engine 与 option_strategy_engine 依次 process；dispatch_contract 交 market_data_engine()->process_contract(event)。

### 5.3 小结

- 事件发到引擎后，在同一处按固定顺序调用，顺序在 .cpp 里写死；register_handler 为 no-op。
- Core 产出的 LogIntent 由调用方/Runtime 经 put_log_intent 或 append_log 打出，LogEngine 按 level 过滤后输出。

---

## 六、执行层

### 6.1 下单/撤单接口

- 已统一为 **OrderRequest** / **CancelRequest**。策略侧入口为 OptionStrategyEngine::send_order(req)、cancel_order(req)，内部调 main_engine_->append_order(req)、append_cancel(req)。Hedge 产出的 orders/cancels 由 EventEngine 用同一套 main_engine_->send_order/cancel_order 执行。

### 6.2 回测执行

- append_order → MainEngine::send_order(req) → order_executor_(req) 即 BacktestEngine::execute_order：生成 orderid、撮合、add_order、put_event(Order)、put_event(Trade)。append_cancel → MainEngine::cancel_order(req)：更新订单状态并 put_event(Order)。回报经 put_event 回到 EventEngine，再 dispatch_order/dispatch_trade 更新状态。

### 6.3 Live 执行

- append_order/append_cancel → MainEngine::send_order/cancel_order → IbGateway。与回测仅在「谁执行」上不同，接口形态一致。未抽象 ExecutionAdapter。

---

## 七、小结表

| 项目           | 现状 |
|----------------|------|
| Event 形态     | Timer/Order/Trade/Contract/Snapshot + EventPayload（含 PortfolioSnapshot）；Log 为 Intent（put_log_intent/append_log） |
| 事件入口       | 回测：每步先 put_event(Snapshot)，再 put_event(Timer)；回报 main_engine_->put_event(Order/Trade) 转 event_engine_->put_event。Live：put(event) 入队，worker process |
| MainEngine.put_event | 虚函数，backtest/live 均 override，转发到 event_engine_->put_event（回测同步、live 入队） |
| Intent 提交    | Strategy/Hedge 不持 event_engine，统一经 main_engine->append_order/append_cancel/append_log；内部转 send_order/cancel_order/put_log_intent |
| 事件分发       | 回测与 live 均写死顺序、无 handler 注册；回测支持 Snapshot→Timer，live 支持 Snapshot/Timer/Contract |
| Log 控制       | LogEngine set_level/level（data.level >= level_ 才输出）；MainEngine::set_log_level/log_level，回测与 live 一致 |
| Core 入参      | 全部 caller 传参；HedgeParams 仅只读；HedgeEngine 通过 out_orders/out_cancels/out_logs 产出，由 Runtime 执行 |
| Core 入口      | 未收敛为 step(Event)→Intent；仍由 EventEngine 按类型多次调用 on_timer/update_metrics/process_hedging/process_order/process_trade 等 |
| 执行层         | 统一 OrderRequest/CancelRequest；回测 order_executor 撮合 + put_event 回报，live IbGateway；未抽象 ExecutionAdapter |
| BaseEngine/LogEngine | 不持 IEventEngine；LogEngine(MainEngine*) 单参 |
| 回测每步顺序   | put_event(Snapshot) → dispatch_snapshot(apply_frame) → put_event(Timer) → on_timer → update_metrics → process_hedging → 执行 orders/cancels/logs |
| Live Timer 顺序| process_timer_event → put_log_intent(pos_logs)；再每策略 process_hedging → 执行 orders/cancels/logs |

---

## 附录

### A.1 Event 形态

| 类型    | 含义           | 当前用法 |
|---------|----------------|----------|
| Timer   | 时钟/周期驱动  | 回测 BacktestEngine 按 timestep 推；live EventEngine 定时线程 put |
| Snapshot| 组合快照       | 回测每步 put_event(Snapshot, get_precomputed_snapshot(i))，dispatch_snapshot 中 portfolio->apply_frame；live 可由行情侧组 snapshot 后 put |
| Order   | 订单状态更新   | 回报时 put_event(Order, OrderData) |
| Trade   | 成交回报       | 撮合/Gateway 回报时 put_event(Trade, TradeData) |
| Contract| 合约信息       | Live dispatch_contract → market_data_engine |
| Log     | 无独立 Event   | 经 append_log/put_log_intent(LogData) → MainEngine → LogEngine |

### A.2 Intent 与 append_*

| 意图     | 当前提交方式 |
|----------|--------------|
| 下单     | 策略/Hedge → main_engine->append_order(req) → send_order；EventEngine 内 hedge 产出 → main_engine_->send_order(o) |
| 撤单     | append_cancel(req) → cancel_order；或 main_engine_->cancel_order(c) |
| 日志     | append_log(log) → put_log_intent；或 main_engine_->put_log_intent(l) |

### A.3 组件与职责

| 职责           | 现有组件 |
|----------------|----------|
| Domain Core    | core/：PositionEngine、HedgeEngine、ComboBuilderEngine（caller 传参；Hedge 产出 orders/cancels/logs 由 Runtime 执行） |
| Runtime 回测   | backtest/engines/：EventEngine（写死顺序、Snapshot+Timer）、MainEngine（put_event 转发、append_*、set_log_level）、OptionStrategyEngine（仅 main_engine）、BacktestEngine（撮合+put_event 回报）、BacktestDataEngine（预计算 snapshot） |
| Runtime 实盘   | live/：EventEngine（队列+定时器）、MainEngine（put_event 转发、append_*、set_log_level）、OptionStrategyEngine、MarketDataEngine（portfolios+contracts、process_contract、apply_frame）、DatabaseEngine、IbGateway |
| 执行           | 回测：append_order → send_order → order_executor；live：append_order → send_order → IbGateway |
| Log            | put_log_intent → LogEngine；LogEngine 按 level 过滤，MainEngine::set_log_level/log_level |

### A.4 逻辑闭环（当前形态）

```
回测：iter_timesteps → put_event(Snapshot) → dispatch_snapshot(apply_frame)
     → put_event(Timer) → EventEngine process → dispatch_timer → on_timer / update_metrics / process_hedging → intents
     → main_engine_->send_order/cancel_order/put_log_intent
     → 撮合/撤单 → main_engine_->put_event(Order/Trade) → event_engine_->put_event → dispatch_order/dispatch_trade

Live：定时器/外部 → put(Event) → process → dispatch_* → position/hedge 产出 intents
     → send_order/cancel_order/put_log_intent → Gateway 执行
     → 回报 main_engine->put_event → event_engine->put(e) 入队 → 下一轮 process 更新状态
```

Strategy/Hedge 只读入参、产出 orders/cancels/logs 或 out_logs；执行与回灌均经 MainEngine（append_*、put_event），不直接依赖 IEventEngine。

### A.5 文件命名

- 引擎文件已统一为 **engine_\<name\>.{cpp,hpp}**（如 engine_backtest、engine_main、engine_event、engine_data、engine_position、engine_hedge、engine_log、engine_combo_builder、engine_strategy、engine_db、engine_gateway）。
- 接口 IEventEngine 定义在 `utilities/portfolio.hpp`；backtest 命名空间为 `backtest`，live 为 `engines`。
